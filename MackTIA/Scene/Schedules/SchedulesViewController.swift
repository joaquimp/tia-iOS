//
//  SchedulesViewController.swift
//  MackTIA
//
//  Created by Luciano Moreira Turrini on 8/15/16.
//  Copyright (c) 2016 Mackenzie. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit

protocol SchedulesViewControllerInput {
    func displayFetchedSchedules(_ viewModel: SchedulesViewModel.Success)
    func displayFetchedSchedulesError(_ viewModel: SchedulesViewModel.Error)
}

protocol SchedulesViewControllerOutput {
    func fetchSchedules(_ request: SchedulesRequest)
}

class SchedulesViewController: UITableViewController, SchedulesViewControllerInput {
    
    // MARK: Outlets
    
    @IBOutlet weak var reloadButtonItem: UIBarButtonItem!
    let defaultCellIdentifier = "defaultCell"
    let emptyCellIdentifier = "emptyCell"
    let loadingCellIdentifier = "loadingCell"
    var firstLoadingFlag = true
    
    // MARK: properties
    
    var headerView: ScheduleHeaderView?
    var segmentedControl: RS3DSegmentedControl!
    var displayedSchedules:[Schedule] = []
    var filteredSchedules = [Int:[Schedule]]()
    var keysW: [Int] = [1,2,3,4,5,6,7]
    let weekDays = [1 : "DOMINGO", 2 : "SEGUNDA", 3 : "TERÇA", 4 : "QUARTA", 5 : "QUINTA", 6 : "SEXTA" , 7 : "SÁBADO"]
    
    // MARK: VIPER properties
    var output: SchedulesViewControllerOutput!
    var router: SchedulesRouter!
    
    // MARK: Object lifecycle
    
    override func awakeFromNib() {
        super.awakeFromNib()
        SchedulesConfigurator.sharedInstance.configure(self)
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.setupHeaderView()
        self.setupSegmentedControl()
        self.setupHeightCell()
        self.configInterfaceAnimations()
        self.fetchSchedules()
        
        let swipeRight = UISwipeGestureRecognizer(target: self, action: #selector(SchedulesViewController.swipeGesture(_:)))
        let swipeLeft = UISwipeGestureRecognizer(target: self, action: #selector(SchedulesViewController.swipeGesture(_:)))
        swipeRight.direction = .right
        swipeLeft.direction  = .left
        self.tableView.addGestureRecognizer(swipeRight)
        self.tableView.addGestureRecognizer(swipeLeft)
    }
    
    // MARK: Interface Animations
    
    func swipeGesture(_ sender: UISwipeGestureRecognizer) {
        
        if sender.direction == .left {
            let position = Int(self.segmentedControl.selectedSegmentIndex)
            let nextPosition = (position == self.keysW.count-1) ? 0 : position+1
            self.segmentedControl.selectedSegmentIndex = UInt(nextPosition)
        } else {
            let position = Int(self.segmentedControl.selectedSegmentIndex)
            let nextPosition = (position == 0) ? self.keysW.count-1 : position-1
            self.segmentedControl.selectedSegmentIndex = UInt(nextPosition)
        }
    }
    
    fileprivate func setupHeightCell() -> Void {
        self.tableView.rowHeight = UITableViewAutomaticDimension
        self.tableView.estimatedRowHeight = 100.0
    }
    
    func configInterfaceAnimations() {
        self.refreshControl?.addTarget(self, action: #selector(SchedulesViewController.handleRefresh(_:)), for: UIControlEvents.valueChanged)
    }
    
    fileprivate func startReloadAnimation() {
        self.reloadButtonItem.isEnabled = false
        self.navigationItem.title = "Carregando Horários"
    }
    
    fileprivate func stopReloadAnimation() {
        reloadButtonItem.isEnabled = true
        refreshControl?.endRefreshing()
        self.navigationItem.title = "Horários"
    }
    
    fileprivate func setupHeaderView() -> Void {
        self.headerView = self.loadHeaderView()
    }
    
    fileprivate func loadHeaderView() -> ScheduleHeaderView? {
        let nibViews = Bundle.main.loadNibNamed("ScheduleHeaderView", owner: self, options: nil)
        return nibViews?.first as? ScheduleHeaderView
    }
    
    // MARK: Event handling
    
    func handleRefresh(_ refreshControl: UIRefreshControl) {
        self.startReloadAnimation()
        let delayInSeconds = 1.0;
        let popTime = DispatchTime.now() + Double(Int64(delayInSeconds * Double(NSEC_PER_SEC))) / Double(NSEC_PER_SEC);
        DispatchQueue.main.asyncAfter(deadline: popTime) { [weak self] () -> Void in
            self?.fetchSchedules()
        }
    }
    
    func fetchSchedules() -> Void {
        self.startReloadAnimation()
        let request = SchedulesRequest()
        output.fetchSchedules(request)
    }
    
    @IBAction func refreshAction(_ sender: AnyObject) {
        self.fetchSchedules()
    }
    
    @IBAction func routeButtonTouched(_ sender: UIButton) {
        if let cell = sender.superview?.superview as? ScheduleTableViewCell {
            let indexPath = tableView.indexPath(for: cell)!
            let schedule = self.displayedSchedules[(indexPath as NSIndexPath).row]
            
            if let nav = self.tabBarController?.viewControllers![3] as? UINavigationController {
                if let vc = nav.topViewController as? CampusMapViewController {
                    vc.traceRouteTo(buildNumber: schedule.buildingNumber ?? "")
                    self.tabBarController?.selectedIndex = 3
                }
            }
        }
    }
    
    
    // MARK: Display logic
    
    func displayFetchedSchedules(_ viewModel: SchedulesViewModel.Success) {
        self.stopReloadAnimation()
        filteredSchedules = viewModel.displayedSchedules
        if (filteredSchedules.count > 0) {
            self.firstLoadingFlag = false
            DispatchQueue.main.async {
                self.segmentedControl.selectedSegmentIndex = UInt((Date.getDayOfWeek() ?? 1)-1)
                self.segmentedControl.carousel.reloadData()
                self.tableView.reloadData()
            }
        }
    }
    
    func displayFetchedSchedulesError(_ viewModel: SchedulesViewModel.Error) {
        self.stopReloadAnimation()
        
        let alert = UIAlertController(title: viewModel.errorTitle, message: viewModel.errorMessage, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
        self.present(alert, animated: true, completion: nil)
    }
    
    fileprivate func dateScheduleFormatter(_ stringToParser: String) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyyMMdd"
        formatter.timeZone = TimeZone(abbreviation: "BRST")
        formatter.locale = Locale(identifier: "pt_BR")
        
        var stringDate: String?
        if let date = formatter.date(from: stringToParser) {
            formatter.dateFormat = "dd/MM/yyyy"
            stringDate = formatter.string(from: date)
        }
        
        stringDate = stringDate ?? ""
        return stringDate!
    }
    
    // Usar para colocar o dia atual na Segmented
    fileprivate func getDay(_ date: Date) -> Int {
        let formatter = DateFormatter()
        formatter.timeZone = TimeZone(abbreviation: "BRST")
        formatter.locale = Locale(identifier: "pt_BR")
        formatter.dateFormat = "dd"
        let string: String = formatter.string(from: date)
        
        return Int(string)!
    }
    
}

// MARK: TableView Delegate Methods

extension SchedulesViewController {
    
    override func numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }
    
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        
        let number = self.displayedSchedules.count
        
        if number == 0 {
//            self.showEmptyMessage(NSLocalizedString("empty_table_schedule", comment: "Sem horario disponivel"))
            return 1
        }
        return number
    }
    
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        if self.displayedSchedules.count > 0 {
            
            let schedule = self.displayedSchedules[(indexPath as NSIndexPath).row]
            
            let cell = self.tableView.dequeueReusableCell(withIdentifier: self.defaultCellIdentifier, for: indexPath) as! ScheduleTableViewCell
            
            let dateFormat = DateFormatter()
            dateFormat.dateFormat = "HH:mm"
            dateFormat.timeZone = TimeZone(identifier: "GMT-3")
            
            cell.disciplineLabel.text = schedule.discipline
            cell.rangeTimeLabel.text = "\(dateFormat.string(from: schedule.startTime as Date? ?? Date())) - \(dateFormat.string(from: schedule.endTime as Date? ?? Date()))"
            cell.classNameLabel.text = schedule.className
            cell.collegeNameLabel.text = schedule.collegeName
            cell.buildingNumberLabel?.text = schedule.buildingNumber
            cell.numberRoomLabel?.text = schedule.numberRoom
            if let updateAt = schedule.updatedAt {
                cell.updatedAtLabel?.text = "ATUALIZADO EM \(self.dateScheduleFormatter(updateAt))"
            }
            
            return cell
        } else if self.firstLoadingFlag {
            let cell = self.tableView.dequeueReusableCell(withIdentifier: self.loadingCellIdentifier, for: indexPath)
            return cell
        } else {
            let cell = self.tableView.dequeueReusableCell(withIdentifier: self.emptyCellIdentifier, for: indexPath)
            return cell
        }
    }
    
    override func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        if let header = self.headerView {
            return header
        }
        return nil
    }
    
    override func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        return 50
    }
    
    override func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {
        return 0.001
    }
    
}

// MARK: Segmented Control

extension SchedulesViewController: RS3DSegmentedControlDelegate {
    
    fileprivate func setupSegmentedControl() -> Void {
        self.segmentedControl = RS3DSegmentedControl(frame: CGRect(x: 0, y: 0, width: self.view.frame.size.width, height: 50))
        self.segmentedControl?.delegate = self
        self.headerView?.viewForSegmented.addSubview(segmentedControl)
        self.segmentedControl.selectedSegmentIndex = 0
        self.segmentedControl?.textFont = UIFont(name: "Bariol_Regular", size: 35)
        self.segmentedControl?.textColor = UIColor.red
    }
    
    func number(ofSegmentsIn3DSegmentedControl segmentedControl: RS3DSegmentedControl!) -> UInt {
        //        self.keysW = Array(filteredSchedules.keys)
        //        return UInt(filteredSchedules.count)
        return UInt(self.keysW.count)
    }
    
    func titleForSegment(at segmentIndex: UInt, segmentedControl: RS3DSegmentedControl!) -> String! {
        let day = weekDays[self.keysW[Int(segmentIndex)]]
        return day
    }
    
    func didSelectSegment(at segmentIndex: UInt, segmentedControl: RS3DSegmentedControl!) {
        
        let scheduleIndex = self.keysW[Int(segmentIndex)]
        
        if filteredSchedules.keys.contains(scheduleIndex) {
            if let schedules = filteredSchedules[scheduleIndex] {
                self.displayedSchedules = schedules
                self.tableView.reloadData()
            }
        }
    }
}
